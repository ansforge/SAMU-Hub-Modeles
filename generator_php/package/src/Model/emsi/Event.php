<?php
/**
 * Event
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Hubsante
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAPI
 *
 * OpenAPI
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Hubsante\Model\emsi;

use \ArrayAccess;
use \Hubsante\ObjectSerializer;

/**
 * Event Class Doc Comment
 *
 * @category Class
 * @package  Hubsante
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Event implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'event';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'iD' => 'string',
        'nAME' => 'string',
        'mAINEVENTID' => 'string',
        'eTYPE' => '\Hubsante\Model\emsi\Etype',
        'sOURCE' => 'string',
        'sCALE' => 'string',
        'cERTAINTY' => 'int',
        'dECLDATIME' => '\DateTime',
        'oCCDATIME' => '\DateTime',
        'oBSDATIME' => '\DateTime',
        'sTATUS' => 'string',
        'rISKASSESMENT' => 'string',
        'rEFERENCE' => '\Hubsante\Model\emsi\Reference[]',
        'cASUALTIES' => '\Hubsante\Model\emsi\Casualties[]',
        'eVAC' => '\Hubsante\Model\emsi\Evac[]',
        'eGEO' => '\Hubsante\Model\emsi\Egeo[]',
        'cAUSE' => 'string',
        'fREETEXT' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'iD' => null,
        'nAME' => null,
        'mAINEVENTID' => null,
        'eTYPE' => null,
        'sOURCE' => null,
        'sCALE' => null,
        'cERTAINTY' => null,
        'dECLDATIME' => 'date-time',
        'oCCDATIME' => 'date-time',
        'oBSDATIME' => 'date-time',
        'sTATUS' => null,
        'rISKASSESMENT' => null,
        'rEFERENCE' => null,
        'cASUALTIES' => null,
        'eVAC' => null,
        'eGEO' => null,
        'cAUSE' => null,
        'fREETEXT' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'iD' => false,
        'nAME' => false,
        'mAINEVENTID' => false,
        'eTYPE' => false,
        'sOURCE' => false,
        'sCALE' => false,
        'cERTAINTY' => false,
        'dECLDATIME' => false,
        'oCCDATIME' => false,
        'oBSDATIME' => false,
        'sTATUS' => false,
        'rISKASSESMENT' => false,
        'rEFERENCE' => false,
        'cASUALTIES' => false,
        'eVAC' => false,
        'eGEO' => false,
        'cAUSE' => false,
        'fREETEXT' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'iD' => 'ID',
        'nAME' => 'NAME',
        'mAINEVENTID' => 'MAIN_EVENT_ID',
        'eTYPE' => 'ETYPE',
        'sOURCE' => 'SOURCE',
        'sCALE' => 'SCALE',
        'cERTAINTY' => 'CERTAINTY',
        'dECLDATIME' => 'DECL_DATIME',
        'oCCDATIME' => 'OCC_DATIME',
        'oBSDATIME' => 'OBS_DATIME',
        'sTATUS' => 'STATUS',
        'rISKASSESMENT' => 'RISK_ASSESMENT',
        'rEFERENCE' => 'REFERENCE',
        'cASUALTIES' => 'CASUALTIES',
        'eVAC' => 'EVAC',
        'eGEO' => 'EGEO',
        'cAUSE' => 'CAUSE',
        'fREETEXT' => 'FREETEXT'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'iD' => 'setID',
        'nAME' => 'setNAME',
        'mAINEVENTID' => 'setMAINEVENTID',
        'eTYPE' => 'setETYPE',
        'sOURCE' => 'setSOURCE',
        'sCALE' => 'setSCALE',
        'cERTAINTY' => 'setCERTAINTY',
        'dECLDATIME' => 'setDECLDATIME',
        'oCCDATIME' => 'setOCCDATIME',
        'oBSDATIME' => 'setOBSDATIME',
        'sTATUS' => 'setSTATUS',
        'rISKASSESMENT' => 'setRISKASSESMENT',
        'rEFERENCE' => 'setREFERENCE',
        'cASUALTIES' => 'setCASUALTIES',
        'eVAC' => 'setEVAC',
        'eGEO' => 'setEGEO',
        'cAUSE' => 'setCAUSE',
        'fREETEXT' => 'setFREETEXT'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'iD' => 'getID',
        'nAME' => 'getNAME',
        'mAINEVENTID' => 'getMAINEVENTID',
        'eTYPE' => 'getETYPE',
        'sOURCE' => 'getSOURCE',
        'sCALE' => 'getSCALE',
        'cERTAINTY' => 'getCERTAINTY',
        'dECLDATIME' => 'getDECLDATIME',
        'oCCDATIME' => 'getOCCDATIME',
        'oBSDATIME' => 'getOBSDATIME',
        'sTATUS' => 'getSTATUS',
        'rISKASSESMENT' => 'getRISKASSESMENT',
        'rEFERENCE' => 'getREFERENCE',
        'cASUALTIES' => 'getCASUALTIES',
        'eVAC' => 'getEVAC',
        'eGEO' => 'getEGEO',
        'cAUSE' => 'getCAUSE',
        'fREETEXT' => 'getFREETEXT'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const S_OURCE_COMFOR = 'COMFOR';
    public const S_OURCE_HUMDED = 'HUMDED';
    public const S_OURCE_HUMOBS = 'HUMOBS';
    public const S_OURCE_SENSOR = 'SENSOR';
    public const S_CALE__1 = '1';
    public const S_CALE__2 = '2';
    public const S_CALE__3 = '3';
    public const S_CALE__4 = '4';
    public const S_CALE__5 = '5';
    public const S_TATUS_COM = 'COM';
    public const S_TATUS_IPR = 'IPR';
    public const S_TATUS_NST = 'NST';
    public const S_TATUS_STOP = 'STOP';
    public const R_ISKASSESMENT_NCREA = 'NCREA';
    public const R_ISKASSESMENT_DECREA = 'DECREA';
    public const R_ISKASSESMENT_STABLE = 'STABLE';
    public const C_AUSE_ACC = 'ACC';
    public const C_AUSE_DEL = 'DEL';
    public const C_AUSE_NAT = 'NAT';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSOURCEAllowableValues()
    {
        return [
            self::S_OURCE_COMFOR,
            self::S_OURCE_HUMDED,
            self::S_OURCE_HUMOBS,
            self::S_OURCE_SENSOR,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSCALEAllowableValues()
    {
        return [
            self::S_CALE__1,
            self::S_CALE__2,
            self::S_CALE__3,
            self::S_CALE__4,
            self::S_CALE__5,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSTATUSAllowableValues()
    {
        return [
            self::S_TATUS_COM,
            self::S_TATUS_IPR,
            self::S_TATUS_NST,
            self::S_TATUS_STOP,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRISKASSESMENTAllowableValues()
    {
        return [
            self::R_ISKASSESMENT_NCREA,
            self::R_ISKASSESMENT_DECREA,
            self::R_ISKASSESMENT_STABLE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCAUSEAllowableValues()
    {
        return [
            self::C_AUSE_ACC,
            self::C_AUSE_DEL,
            self::C_AUSE_NAT,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('iD', $data ?? [], null);
        $this->setIfExists('nAME', $data ?? [], null);
        $this->setIfExists('mAINEVENTID', $data ?? [], null);
        $this->setIfExists('eTYPE', $data ?? [], null);
        $this->setIfExists('sOURCE', $data ?? [], null);
        $this->setIfExists('sCALE', $data ?? [], null);
        $this->setIfExists('cERTAINTY', $data ?? [], null);
        $this->setIfExists('dECLDATIME', $data ?? [], null);
        $this->setIfExists('oCCDATIME', $data ?? [], null);
        $this->setIfExists('oBSDATIME', $data ?? [], null);
        $this->setIfExists('sTATUS', $data ?? [], null);
        $this->setIfExists('rISKASSESMENT', $data ?? [], null);
        $this->setIfExists('rEFERENCE', $data ?? [], null);
        $this->setIfExists('cASUALTIES', $data ?? [], null);
        $this->setIfExists('eVAC', $data ?? [], null);
        $this->setIfExists('eGEO', $data ?? [], null);
        $this->setIfExists('cAUSE', $data ?? [], null);
        $this->setIfExists('fREETEXT', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['iD'] === null) {
            $invalidProperties[] = "'iD' can't be null";
        }
        $allowedValues = $this->getSOURCEAllowableValues();
        if (!is_null($this->container['sOURCE']) && !in_array($this->container['sOURCE'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sOURCE', must be one of '%s'",
                $this->container['sOURCE'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSCALEAllowableValues();
        if (!is_null($this->container['sCALE']) && !in_array($this->container['sCALE'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sCALE', must be one of '%s'",
                $this->container['sCALE'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['dECLDATIME']) && !preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", $this->container['dECLDATIME'])) {
            $invalidProperties[] = "invalid value for 'dECLDATIME', must be conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.";
        }

        if (!is_null($this->container['oCCDATIME']) && !preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", $this->container['oCCDATIME'])) {
            $invalidProperties[] = "invalid value for 'oCCDATIME', must be conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.";
        }

        if (!is_null($this->container['oBSDATIME']) && !preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", $this->container['oBSDATIME'])) {
            $invalidProperties[] = "invalid value for 'oBSDATIME', must be conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.";
        }

        $allowedValues = $this->getSTATUSAllowableValues();
        if (!is_null($this->container['sTATUS']) && !in_array($this->container['sTATUS'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sTATUS', must be one of '%s'",
                $this->container['sTATUS'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRISKASSESMENTAllowableValues();
        if (!is_null($this->container['rISKASSESMENT']) && !in_array($this->container['rISKASSESMENT'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'rISKASSESMENT', must be one of '%s'",
                $this->container['rISKASSESMENT'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCAUSEAllowableValues();
        if (!is_null($this->container['cAUSE']) && !in_array($this->container['cAUSE'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'cAUSE', must be one of '%s'",
                $this->container['cAUSE'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets iD
     *
     * @return string
     */
    public function getID()
    {
        return $this->container['iD'];
    }

    /**
     * Sets iD
     *
     * @param string $iD A renseigner avec l'identifiant local de l'affaire dans le LRM ou NexSIS
     *
     * @return self
     */
    public function setID($iD)
    {
        if (is_null($iD)) {
            throw new \InvalidArgumentException('non-nullable iD cannot be null');
        }
        $this->container['iD'] = $iD;

        return $this;
    }

    /**
     * Gets nAME
     *
     * @return string|null
     */
    public function getNAME()
    {
        return $this->container['nAME'];
    }

    /**
     * Sets nAME
     *
     * @param string|null $nAME Optionnel Dans nexSIS; [libelle NF 1 métier] & \" - \" & [libelle TL 1 métier] & \" - \" & [libellé commune]
     *
     * @return self
     */
    public function setNAME($nAME)
    {
        if (is_null($nAME)) {
            throw new \InvalidArgumentException('non-nullable nAME cannot be null');
        }
        $this->container['nAME'] = $nAME;

        return $this;
    }

    /**
     * Gets mAINEVENTID
     *
     * @return string|null
     */
    public function getMAINEVENTID()
    {
        return $this->container['mAINEVENTID'];
    }

    /**
     * Sets mAINEVENTID
     *
     * @param string|null $mAINEVENTID A renseigner avec l'identifiant de l'organisation (champ organization du message RC-EDA) suivi de l'identifiant local de l'affaire du partenaire requérant (champ senderCaseId du message RC-EDA). {pays}.{domaine}.{organisation}.{structure interne}*.{unité fonctionnelle}*.{numéro de dossier}  NB : Si l'initiateur du partage de dossier est le même que l'initiateur du message EMSI, l'EVENT.ID = EVENT.MAIN_EVENT_ID
     *
     * @return self
     */
    public function setMAINEVENTID($mAINEVENTID)
    {
        if (is_null($mAINEVENTID)) {
            throw new \InvalidArgumentException('non-nullable mAINEVENTID cannot be null');
        }
        $this->container['mAINEVENTID'] = $mAINEVENTID;

        return $this;
    }

    /**
     * Gets eTYPE
     *
     * @return \Hubsante\Model\emsi\Etype|null
     */
    public function getETYPE()
    {
        return $this->container['eTYPE'];
    }

    /**
     * Sets eTYPE
     *
     * @param \Hubsante\Model\emsi\Etype|null $eTYPE eTYPE
     *
     * @return self
     */
    public function setETYPE($eTYPE)
    {
        if (is_null($eTYPE)) {
            throw new \InvalidArgumentException('non-nullable eTYPE cannot be null');
        }
        $this->container['eTYPE'] = $eTYPE;

        return $this;
    }

    /**
     * Gets sOURCE
     *
     * @return string|null
     */
    public function getSOURCE()
    {
        return $this->container['sOURCE'];
    }

    /**
     * Sets sOURCE
     *
     * @param string|null $sOURCE Optionnel
     *
     * @return self
     */
    public function setSOURCE($sOURCE)
    {
        if (is_null($sOURCE)) {
            throw new \InvalidArgumentException('non-nullable sOURCE cannot be null');
        }
        $allowedValues = $this->getSOURCEAllowableValues();
        if (!in_array($sOURCE, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sOURCE', must be one of '%s'",
                    $sOURCE,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sOURCE'] = $sOURCE;

        return $this;
    }

    /**
     * Gets sCALE
     *
     * @return string|null
     */
    public function getSCALE()
    {
        return $this->container['sCALE'];
    }

    /**
     * Sets sCALE
     *
     * @param string|null $sCALE Optionnel, Niveau de criticité de l'opération
     *
     * @return self
     */
    public function setSCALE($sCALE)
    {
        if (is_null($sCALE)) {
            throw new \InvalidArgumentException('non-nullable sCALE cannot be null');
        }
        $allowedValues = $this->getSCALEAllowableValues();
        if (!in_array($sCALE, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sCALE', must be one of '%s'",
                    $sCALE,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sCALE'] = $sCALE;

        return $this;
    }

    /**
     * Gets cERTAINTY
     *
     * @return int|null
     */
    public function getCERTAINTY()
    {
        return $this->container['cERTAINTY'];
    }

    /**
     * Sets cERTAINTY
     *
     * @param int|null $cERTAINTY Prend une valeur entière entre 0 et 100, et décrit à quel point l'alerte associée à l'événement est fiable Optionnel
     *
     * @return self
     */
    public function setCERTAINTY($cERTAINTY)
    {
        if (is_null($cERTAINTY)) {
            throw new \InvalidArgumentException('non-nullable cERTAINTY cannot be null');
        }
        $this->container['cERTAINTY'] = $cERTAINTY;

        return $this;
    }

    /**
     * Gets dECLDATIME
     *
     * @return \DateTime|null
     */
    public function getDECLDATIME()
    {
        return $this->container['dECLDATIME'];
    }

    /**
     * Sets dECLDATIME
     *
     * @param \DateTime|null $dECLDATIME Dans le cadre d'une demande de concours, ce champ est valorisé avec la date/heure de création de l'affaire ou de l'opération. NexSIS transmettra la date/heure de création de l'opération dans ses systèmes (qui peut diverger de la date/heure de création de l'affaire)
     *
     * @return self
     */
    public function setDECLDATIME($dECLDATIME)
    {
        if (is_null($dECLDATIME)) {
            throw new \InvalidArgumentException('non-nullable dECLDATIME cannot be null');
        }

        if ((!preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", ObjectSerializer::toString($dECLDATIME)))) {
            throw new \InvalidArgumentException("invalid value for \$dECLDATIME when calling Event., must conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.");
        }

        $this->container['dECLDATIME'] = $dECLDATIME;

        return $this;
    }

    /**
     * Gets oCCDATIME
     *
     * @return \DateTime|null
     */
    public function getOCCDATIME()
    {
        return $this->container['oCCDATIME'];
    }

    /**
     * Sets oCCDATIME
     *
     * @param \DateTime|null $oCCDATIME Dans le cadre d'une demande de concours, ce champ est valorisé avec la date de la première alerte ou la date évaluée de début de la situation d'urgence. Par exemple : Si un incendie est déclaré est 9h02, il a pu démarré à 8h55 par exemple. NB : temporairement, NexSIS renseignera ce champ avec la date de réception de l'alerte initiale
     *
     * @return self
     */
    public function setOCCDATIME($oCCDATIME)
    {
        if (is_null($oCCDATIME)) {
            throw new \InvalidArgumentException('non-nullable oCCDATIME cannot be null');
        }

        if ((!preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", ObjectSerializer::toString($oCCDATIME)))) {
            throw new \InvalidArgumentException("invalid value for \$oCCDATIME when calling Event., must conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.");
        }

        $this->container['oCCDATIME'] = $oCCDATIME;

        return $this;
    }

    /**
     * Gets oBSDATIME
     *
     * @return \DateTime|null
     */
    public function getOBSDATIME()
    {
        return $this->container['oBSDATIME'];
    }

    /**
     * Sets oBSDATIME
     *
     * @param \DateTime|null $oBSDATIME Ce champ est idéalement à valoriser avec la date/heure à laquelle l'observation de la situation d'urgence de l'affaire la plus récente a été réalisée. NexSIS transmettra la date/heure d'envoi de la demande de concours dans son système. NB : temporairement, NexSIS renseignera ce champ avec la date de réception de l'alerte initiale
     *
     * @return self
     */
    public function setOBSDATIME($oBSDATIME)
    {
        if (is_null($oBSDATIME)) {
            throw new \InvalidArgumentException('non-nullable oBSDATIME cannot be null');
        }

        if ((!preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", ObjectSerializer::toString($oBSDATIME)))) {
            throw new \InvalidArgumentException("invalid value for \$oBSDATIME when calling Event., must conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.");
        }

        $this->container['oBSDATIME'] = $oBSDATIME;

        return $this;
    }

    /**
     * Gets sTATUS
     *
     * @return string|null
     */
    public function getSTATUS()
    {
        return $this->container['sTATUS'];
    }

    /**
     * Sets sTATUS
     *
     * @param string|null $sTATUS Permet de décrire le status de l'affaire en cours. Ce champ suit une nomenclature EMSI. (COM = event complete, IPR = event in progress, NST = event not started, STOP = STOP = event under control, no need for additional resource) Dans le cadre d'une opération : - si l'opération est encore en cours : rensigner 'IPR', - si le dispatching de moyens est encore en cours ou que seulement des qualifications d'alertes ont été échangées sans aucune décision de régulation 'NST', - si l'opération est en pause/veille : 'STOP' - si le message d'échange opérationnel décrit une fin d'opération, à renseigner avec 'COM' Un message EMSI-EO sans RESSOURCE ni
     *
     * @return self
     */
    public function setSTATUS($sTATUS)
    {
        if (is_null($sTATUS)) {
            throw new \InvalidArgumentException('non-nullable sTATUS cannot be null');
        }
        $allowedValues = $this->getSTATUSAllowableValues();
        if (!in_array($sTATUS, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sTATUS', must be one of '%s'",
                    $sTATUS,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sTATUS'] = $sTATUS;

        return $this;
    }

    /**
     * Gets rISKASSESMENT
     *
     * @return string|null
     */
    public function getRISKASSESMENT()
    {
        return $this->container['rISKASSESMENT'];
    }

    /**
     * Sets rISKASSESMENT
     *
     * @param string|null $rISKASSESMENT Optionnel
     *
     * @return self
     */
    public function setRISKASSESMENT($rISKASSESMENT)
    {
        if (is_null($rISKASSESMENT)) {
            throw new \InvalidArgumentException('non-nullable rISKASSESMENT cannot be null');
        }
        $allowedValues = $this->getRISKASSESMENTAllowableValues();
        if (!in_array($rISKASSESMENT, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'rISKASSESMENT', must be one of '%s'",
                    $rISKASSESMENT,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['rISKASSESMENT'] = $rISKASSESMENT;

        return $this;
    }

    /**
     * Gets rEFERENCE
     *
     * @return \Hubsante\Model\emsi\Reference[]|null
     */
    public function getREFERENCE()
    {
        return $this->container['rEFERENCE'];
    }

    /**
     * Sets rEFERENCE
     *
     * @param \Hubsante\Model\emsi\Reference[]|null $rEFERENCE rEFERENCE
     *
     * @return self
     */
    public function setREFERENCE($rEFERENCE)
    {
        if (is_null($rEFERENCE)) {
            throw new \InvalidArgumentException('non-nullable rEFERENCE cannot be null');
        }
        $this->container['rEFERENCE'] = $rEFERENCE;

        return $this;
    }

    /**
     * Gets cASUALTIES
     *
     * @return \Hubsante\Model\emsi\Casualties[]|null
     */
    public function getCASUALTIES()
    {
        return $this->container['cASUALTIES'];
    }

    /**
     * Sets cASUALTIES
     *
     * @param \Hubsante\Model\emsi\Casualties[]|null $cASUALTIES cASUALTIES
     *
     * @return self
     */
    public function setCASUALTIES($cASUALTIES)
    {
        if (is_null($cASUALTIES)) {
            throw new \InvalidArgumentException('non-nullable cASUALTIES cannot be null');
        }
        $this->container['cASUALTIES'] = $cASUALTIES;

        return $this;
    }

    /**
     * Gets eVAC
     *
     * @return \Hubsante\Model\emsi\Evac[]|null
     */
    public function getEVAC()
    {
        return $this->container['eVAC'];
    }

    /**
     * Sets eVAC
     *
     * @param \Hubsante\Model\emsi\Evac[]|null $eVAC eVAC
     *
     * @return self
     */
    public function setEVAC($eVAC)
    {
        if (is_null($eVAC)) {
            throw new \InvalidArgumentException('non-nullable eVAC cannot be null');
        }
        $this->container['eVAC'] = $eVAC;

        return $this;
    }

    /**
     * Gets eGEO
     *
     * @return \Hubsante\Model\emsi\Egeo[]|null
     */
    public function getEGEO()
    {
        return $this->container['eGEO'];
    }

    /**
     * Sets eGEO
     *
     * @param \Hubsante\Model\emsi\Egeo[]|null $eGEO eGEO
     *
     * @return self
     */
    public function setEGEO($eGEO)
    {
        if (is_null($eGEO)) {
            throw new \InvalidArgumentException('non-nullable eGEO cannot be null');
        }
        $this->container['eGEO'] = $eGEO;

        return $this;
    }

    /**
     * Gets cAUSE
     *
     * @return string|null
     */
    public function getCAUSE()
    {
        return $this->container['cAUSE'];
    }

    /**
     * Sets cAUSE
     *
     * @param string|null $cAUSE Optionnel
     *
     * @return self
     */
    public function setCAUSE($cAUSE)
    {
        if (is_null($cAUSE)) {
            throw new \InvalidArgumentException('non-nullable cAUSE cannot be null');
        }
        $allowedValues = $this->getCAUSEAllowableValues();
        if (!in_array($cAUSE, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'cAUSE', must be one of '%s'",
                    $cAUSE,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cAUSE'] = $cAUSE;

        return $this;
    }

    /**
     * Gets fREETEXT
     *
     * @return string|null
     */
    public function getFREETEXT()
    {
        return $this->container['fREETEXT'];
    }

    /**
     * Sets fREETEXT
     *
     * @param string|null $fREETEXT Optionnel
     *
     * @return self
     */
    public function setFREETEXT($fREETEXT)
    {
        if (is_null($fREETEXT)) {
            throw new \InvalidArgumentException('non-nullable fREETEXT cannot be null');
        }
        $this->container['fREETEXT'] = $fREETEXT;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


