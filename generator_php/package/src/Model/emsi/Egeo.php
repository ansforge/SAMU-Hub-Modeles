<?php
/**
 * Egeo
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Hubsante
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAPI
 *
 * OpenAPI
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Hubsante\Model\emsi;

use \ArrayAccess;
use \Hubsante\ObjectSerializer;

/**
 * Egeo Class Doc Comment
 *
 * @category Class
 * @package  Hubsante
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Egeo implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'egeo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'dATIME' => '\DateTime',
        'tYPE' => 'string',
        'wEATHER' => 'string[]',
        'fREETEXT' => 'string',
        'pOSITION' => '\Hubsante\Model\emsi\Position'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'dATIME' => 'date-time',
        'tYPE' => null,
        'wEATHER' => null,
        'fREETEXT' => null,
        'pOSITION' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'dATIME' => false,
        'tYPE' => false,
        'wEATHER' => false,
        'fREETEXT' => false,
        'pOSITION' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'dATIME' => 'DATIME',
        'tYPE' => 'TYPE',
        'wEATHER' => 'WEATHER',
        'fREETEXT' => 'FREETEXT',
        'pOSITION' => 'POSITION'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'dATIME' => 'setDATIME',
        'tYPE' => 'setTYPE',
        'wEATHER' => 'setWEATHER',
        'fREETEXT' => 'setFREETEXT',
        'pOSITION' => 'setPOSITION'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'dATIME' => 'getDATIME',
        'tYPE' => 'getTYPE',
        'wEATHER' => 'getWEATHER',
        'fREETEXT' => 'getFREETEXT',
        'pOSITION' => 'getPOSITION'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const T_YPE_AIR = 'AIR';
    public const T_YPE_CMB = 'CMB';
    public const T_YPE_DGR = 'DGR';
    public const T_YPE_FLAME = 'FLAME';
    public const T_YPE_GEN = 'GEN';
    public const T_YPE_PLUME = 'PLUME';
    public const T_YPE_SMOKE = 'SMOKE';
    public const T_YPE_VULN = 'VULN';
    public const T_YPE_AIR_COR = 'AIR/COR';
    public const T_YPE_AIR_FLDZ = 'AIR/FLDZ';
    public const T_YPE_AIR_LZ = 'AIR/LZ';
    public const T_YPE_AIR_NOFLZN = 'AIR/NOFLZN';
    public const T_YPE_AIR_PZ = 'AIR/PZ';
    public const T_YPE_AIR_UAVASP = 'AIR/UAVASP';
    public const T_YPE_CMB_CZ = 'CMB/CZ';
    public const T_YPE_CMB_DNGR = 'CMB/DNGR';
    public const T_YPE_CMB_EXTZN = 'CMB/EXTZN';
    public const T_YPE_CMB_IMPTPT = 'CMB/IMPTPT';
    public const T_YPE_DGR_BIO = 'DGR/BIO';
    public const T_YPE_DGR_BOMB = 'DGR/BOMB';
    public const T_YPE_DGR_CBRNHZ = 'DGR/CBRNHZ';
    public const T_YPE_DGR_CBRNRSD = 'DGR/CBRNRSD';
    public const T_YPE_DGR_CHM = 'DGR/CHM';
    public const T_YPE_DGR_HZD = 'DGR/HZD';
    public const T_YPE_DGR_MIND = 'DGR/MIND';
    public const T_YPE_DGR_NGA = 'DGR/NGA';
    public const T_YPE_DGR_NGACIV = 'DGR/NGACIV';
    public const T_YPE_DGR_NUKCNL = 'DGR/NUKCNL';
    public const T_YPE_DGR_OBSGEN = 'DGR/OBSGEN';
    public const T_YPE_DGR_PRHBAR = 'DGR/PRHBAR';
    public const T_YPE_DGR_RAD = 'DGR/RAD';
    public const T_YPE_DGR_RADCLD = 'DGR/RADCLD';
    public const T_YPE_DGR_RSTR = 'DGR/RSTR';
    public const T_YPE_DGR_SGA = 'DGR/SGA';
    public const T_YPE_DGR_SITKIL = 'DGR/SITKIL';
    public const T_YPE_DGR_UNXOD = 'DGR/UNXOD';
    public const T_YPE_GEN_AOR = 'GEN/AOR';
    public const T_YPE_GEN_ASYGEN = 'GEN/ASYGEN';
    public const T_YPE_GEN_ASYSPL = 'GEN/ASYSPL';
    public const T_YPE_GEN_BDYOR = 'GEN/BDYOR';
    public const T_YPE_GEN_BDYPOA = 'GEN/BDYPOA';
    public const T_YPE_GEN_BDYPT = 'GEN/BDYPT';
    public const T_YPE_GEN_CKPGEN = 'GEN/CKPGEN';
    public const T_YPE_GEN_CNTPTL = 'GEN/CNTPTL';
    public const T_YPE_GEN_COLDZ = 'GEN/COLDZ';
    public const T_YPE_GEN_COMCKP = 'GEN/COMCKP';
    public const T_YPE_GEN_COMLOW = 'GEN/COMLOW';
    public const T_YPE_GEN_COMMZ = 'GEN/COMMZ';
    public const T_YPE_GEN_COMUP = 'GEN/COMUP';
    public const T_YPE_GEN_CONTAR = 'GEN/CONTAR';
    public const T_YPE_GEN_CORDON = 'GEN/CORDON';
    public const T_YPE_GEN_CRDPNT = 'GEN/CRDPNT';
    public const T_YPE_GEN_DIVRT = 'GEN/DIVRT';
    public const T_YPE_GEN_DROPPT = 'GEN/DROPPT';
    public const T_YPE_GEN_ENTPT = 'GEN/ENTPT';
    public const T_YPE_GEN_EVENT = 'GEN/EVENT';
    public const T_YPE_GEN_EXITPT = 'GEN/EXITPT';
    public const T_YPE_GEN_FWCTPT = 'GEN/FWCTPT';
    public const T_YPE_GEN_HOTZ = 'GEN/HOTZ';
    public const T_YPE_GEN_INCGRD = 'GEN/INCGRD';
    public const T_YPE_GEN_LA = 'GEN/LA';
    public const T_YPE_GEN_LIMARE = 'GEN/LIMARE';
    public const T_YPE_GEN_LOCAT = 'GEN/LOCAT';
    public const T_YPE_GEN_MSR = 'GEN/MSR';
    public const T_YPE_GEN_PSSGPT = 'GEN/PSSGPT';
    public const T_YPE_GEN_PTINT = 'GEN/PTINT';
    public const T_YPE_GEN_RCNSAR = 'GEN/RCNSAR';
    public const T_YPE_GEN_RNDZPT = 'GEN/RNDZPT';
    public const T_YPE_GEN_ROUTE = 'GEN/ROUTE';
    public const T_YPE_GEN_SAFERT = 'GEN/SAFERT';
    public const T_YPE_GEN_SAFZ = 'GEN/SAFZ';
    public const T_YPE_GEN_SARPNT = 'GEN/SARPNT';
    public const T_YPE_GEN_SEARAR = 'GEN/SEARAR';
    public const T_YPE_GEN_SPRISK = 'GEN/SPRISK';
    public const T_YPE_GEN_STRTPT = 'GEN/STRTPT';
    public const T_YPE_GEN_SUPARE = 'GEN/SUPARE';
    public const T_YPE_GEN_SUPPT = 'GEN/SUPPT';
    public const T_YPE_GEN_TRSTRT = 'GEN/TRSTRT';
    public const T_YPE_GEN_WARMZ = 'GEN/WARMZ';
    public const W_EATHER_HUM = 'HUM';
    public const W_EATHER_ICY = 'ICY';
    public const W_EATHER_TDS = 'TDS';
    public const W_EATHER_TMP = 'TMP';
    public const W_EATHER_VIS = 'VIS';
    public const W_EATHER_WDS = 'WDS';
    public const W_EATHER_WIN = 'WIN';
    public const W_EATHER_HUM_CORECT = 'HUM/CORECT';
    public const W_EATHER_HUM_DRZLE = 'HUM/DRZLE';
    public const W_EATHER_HUM_FOG = 'HUM/FOG';
    public const W_EATHER_HUM_RAIN = 'HUM/RAIN';
    public const W_EATHER_HUM_RAINSR = 'HUM/RAINSR';
    public const W_EATHER_HUM_THSTRN = 'HUM/THSTRN';
    public const W_EATHER_ICY_BLWSNW = 'ICY/BLWSNW';
    public const W_EATHER_ICY_CLRICE = 'ICY/CLRICE';
    public const W_EATHER_ICY_CORECT = 'ICY/CORECT';
    public const W_EATHER_ICY_FDRZLE = 'ICY/FDRZLE';
    public const W_EATHER_ICY_FRAIN = 'ICY/FRAIN';
    public const W_EATHER_ICY_FRZFOG = 'ICY/FRZFOG';
    public const W_EATHER_ICY_HAIL = 'ICY/HAIL';
    public const W_EATHER_ICY_ICECRY = 'ICY/ICECRY';
    public const W_EATHER_ICY_ICEPLT = 'ICY/ICEPLT';
    public const W_EATHER_ICY_MIXICE = 'ICY/MIXICE';
    public const W_EATHER_ICY_RIMICE = 'ICY/RIMICE';
    public const W_EATHER_ICY_SLEET = 'ICY/SLEET';
    public const W_EATHER_ICY_SNOW = 'ICY/SNOW';
    public const W_EATHER_ICY_SNWGRN = 'ICY/SNWGRN';
    public const W_EATHER_ICY_SNWSHR = 'ICY/SNWSHR';
    public const W_EATHER_TDS_CORECT = 'TDS/CORECT';
    public const W_EATHER_TDS_LGTNNG = 'TDS/LGTNNG';
    public const W_EATHER_TDS_THST = 'TDS/THST';
    public const W_EATHER_VIS_CORECT = 'VIS/CORECT';
    public const W_EATHER_VIS_HAZE = 'VIS/HAZE';
    public const W_EATHER_VIS_SMOKE = 'VIS/SMOKE';
    public const W_EATHER_WIN_CORECT = 'WIN/CORECT';
    public const W_EATHER_WIN_CYCL = 'WIN/CYCL';
    public const W_EATHER_WIN_DSTDVL = 'WIN/DSTDVL';
    public const W_EATHER_WIN_DSTSND = 'WIN/DSTSND';
    public const W_EATHER_WIN_DSTSTR = 'WIN/DSTSTR';
    public const W_EATHER_WIN_FNLCLD = 'WIN/FNLCLD';
    public const W_EATHER_WIN_HURR = 'WIN/HURR';
    public const W_EATHER_WIN_SNDSTR = 'WIN/SNDSTR';
    public const W_EATHER_WIN_STORM = 'WIN/STORM';
    public const W_EATHER_WIN_TORN = 'WIN/TORN';
    public const W_EATHER_WIN_TRST = 'WIN/TRST';
    public const W_EATHER_WIN_TYPH = 'WIN/TYPH';
    public const W_EATHER_WIN_WHIR = 'WIN/WHIR';
    public const W_EATHER_WIN_WTRSPT = 'WIN/WTRSPT';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTYPEAllowableValues()
    {
        return [
            self::T_YPE_AIR,
            self::T_YPE_CMB,
            self::T_YPE_DGR,
            self::T_YPE_FLAME,
            self::T_YPE_GEN,
            self::T_YPE_PLUME,
            self::T_YPE_SMOKE,
            self::T_YPE_VULN,
            self::T_YPE_AIR_COR,
            self::T_YPE_AIR_FLDZ,
            self::T_YPE_AIR_LZ,
            self::T_YPE_AIR_NOFLZN,
            self::T_YPE_AIR_PZ,
            self::T_YPE_AIR_UAVASP,
            self::T_YPE_CMB_CZ,
            self::T_YPE_CMB_DNGR,
            self::T_YPE_CMB_EXTZN,
            self::T_YPE_CMB_IMPTPT,
            self::T_YPE_DGR_BIO,
            self::T_YPE_DGR_BOMB,
            self::T_YPE_DGR_CBRNHZ,
            self::T_YPE_DGR_CBRNRSD,
            self::T_YPE_DGR_CHM,
            self::T_YPE_DGR_HZD,
            self::T_YPE_DGR_MIND,
            self::T_YPE_DGR_NGA,
            self::T_YPE_DGR_NGACIV,
            self::T_YPE_DGR_NUKCNL,
            self::T_YPE_DGR_OBSGEN,
            self::T_YPE_DGR_PRHBAR,
            self::T_YPE_DGR_RAD,
            self::T_YPE_DGR_RADCLD,
            self::T_YPE_DGR_RSTR,
            self::T_YPE_DGR_SGA,
            self::T_YPE_DGR_SITKIL,
            self::T_YPE_DGR_UNXOD,
            self::T_YPE_GEN_AOR,
            self::T_YPE_GEN_ASYGEN,
            self::T_YPE_GEN_ASYSPL,
            self::T_YPE_GEN_BDYOR,
            self::T_YPE_GEN_BDYPOA,
            self::T_YPE_GEN_BDYPT,
            self::T_YPE_GEN_CKPGEN,
            self::T_YPE_GEN_CNTPTL,
            self::T_YPE_GEN_COLDZ,
            self::T_YPE_GEN_COMCKP,
            self::T_YPE_GEN_COMLOW,
            self::T_YPE_GEN_COMMZ,
            self::T_YPE_GEN_COMUP,
            self::T_YPE_GEN_CONTAR,
            self::T_YPE_GEN_CORDON,
            self::T_YPE_GEN_CRDPNT,
            self::T_YPE_GEN_DIVRT,
            self::T_YPE_GEN_DROPPT,
            self::T_YPE_GEN_ENTPT,
            self::T_YPE_GEN_EVENT,
            self::T_YPE_GEN_EXITPT,
            self::T_YPE_GEN_FWCTPT,
            self::T_YPE_GEN_HOTZ,
            self::T_YPE_GEN_INCGRD,
            self::T_YPE_GEN_LA,
            self::T_YPE_GEN_LIMARE,
            self::T_YPE_GEN_LOCAT,
            self::T_YPE_GEN_MSR,
            self::T_YPE_GEN_PSSGPT,
            self::T_YPE_GEN_PTINT,
            self::T_YPE_GEN_RCNSAR,
            self::T_YPE_GEN_RNDZPT,
            self::T_YPE_GEN_ROUTE,
            self::T_YPE_GEN_SAFERT,
            self::T_YPE_GEN_SAFZ,
            self::T_YPE_GEN_SARPNT,
            self::T_YPE_GEN_SEARAR,
            self::T_YPE_GEN_SPRISK,
            self::T_YPE_GEN_STRTPT,
            self::T_YPE_GEN_SUPARE,
            self::T_YPE_GEN_SUPPT,
            self::T_YPE_GEN_TRSTRT,
            self::T_YPE_GEN_WARMZ,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWEATHERAllowableValues()
    {
        return [
            self::W_EATHER_HUM,
            self::W_EATHER_ICY,
            self::W_EATHER_TDS,
            self::W_EATHER_TMP,
            self::W_EATHER_VIS,
            self::W_EATHER_WDS,
            self::W_EATHER_WIN,
            self::W_EATHER_HUM_CORECT,
            self::W_EATHER_HUM_DRZLE,
            self::W_EATHER_HUM_FOG,
            self::W_EATHER_HUM_RAIN,
            self::W_EATHER_HUM_RAINSR,
            self::W_EATHER_HUM_THSTRN,
            self::W_EATHER_ICY_BLWSNW,
            self::W_EATHER_ICY_CLRICE,
            self::W_EATHER_ICY_CORECT,
            self::W_EATHER_ICY_FDRZLE,
            self::W_EATHER_ICY_FRAIN,
            self::W_EATHER_ICY_FRZFOG,
            self::W_EATHER_ICY_HAIL,
            self::W_EATHER_ICY_ICECRY,
            self::W_EATHER_ICY_ICEPLT,
            self::W_EATHER_ICY_MIXICE,
            self::W_EATHER_ICY_RIMICE,
            self::W_EATHER_ICY_SLEET,
            self::W_EATHER_ICY_SNOW,
            self::W_EATHER_ICY_SNWGRN,
            self::W_EATHER_ICY_SNWSHR,
            self::W_EATHER_TDS_CORECT,
            self::W_EATHER_TDS_LGTNNG,
            self::W_EATHER_TDS_THST,
            self::W_EATHER_VIS_CORECT,
            self::W_EATHER_VIS_HAZE,
            self::W_EATHER_VIS_SMOKE,
            self::W_EATHER_WIN_CORECT,
            self::W_EATHER_WIN_CYCL,
            self::W_EATHER_WIN_DSTDVL,
            self::W_EATHER_WIN_DSTSND,
            self::W_EATHER_WIN_DSTSTR,
            self::W_EATHER_WIN_FNLCLD,
            self::W_EATHER_WIN_HURR,
            self::W_EATHER_WIN_SNDSTR,
            self::W_EATHER_WIN_STORM,
            self::W_EATHER_WIN_TORN,
            self::W_EATHER_WIN_TRST,
            self::W_EATHER_WIN_TYPH,
            self::W_EATHER_WIN_WHIR,
            self::W_EATHER_WIN_WTRSPT,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('dATIME', $data ?? [], null);
        $this->setIfExists('tYPE', $data ?? [], null);
        $this->setIfExists('wEATHER', $data ?? [], null);
        $this->setIfExists('fREETEXT', $data ?? [], null);
        $this->setIfExists('pOSITION', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['dATIME']) && !preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", $this->container['dATIME'])) {
            $invalidProperties[] = "invalid value for 'dATIME', must be conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.";
        }

        $allowedValues = $this->getTYPEAllowableValues();
        if (!is_null($this->container['tYPE']) && !in_array($this->container['tYPE'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'tYPE', must be one of '%s'",
                $this->container['tYPE'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets dATIME
     *
     * @return \DateTime|null
     */
    public function getDATIME()
    {
        return $this->container['dATIME'];
    }

    /**
     * Sets dATIME
     *
     * @param \DateTime|null $dATIME Optionnel La localisation de l'affaire est transmise en amont dans un message RC-EDA et le lieu souhaité pour l'intervention est systématiquement reprécisé dans un objet MISSION
     *
     * @return self
     */
    public function setDATIME($dATIME)
    {
        if (is_null($dATIME)) {
            throw new \InvalidArgumentException('non-nullable dATIME cannot be null');
        }

        if ((!preg_match("/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/", ObjectSerializer::toString($dATIME)))) {
            throw new \InvalidArgumentException("invalid value for \$dATIME when calling Egeo., must conform to the pattern /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[\\-+]\\d{2}:\\d{2}$/.");
        }

        $this->container['dATIME'] = $dATIME;

        return $this;
    }

    /**
     * Gets tYPE
     *
     * @return string|null
     */
    public function getTYPE()
    {
        return $this->container['tYPE'];
    }

    /**
     * Sets tYPE
     *
     * @param string|null $tYPE Optionnel La localisation de l'affaire est transmise en amont dans un message RC-EDA et le lieu souhaité pour l'intervention est systématiquement reprécisé dans un objet MISSION. A constituer depuis ref_mapping_EMSI_EVENT_EGEO_TYPE_NEXSIS_ /!\\ plusieurs champs NEXSIS /!\\ plusieurs valeurs par champs d'où un groupe<EGEO> à créer par type différents
     *
     * @return self
     */
    public function setTYPE($tYPE)
    {
        if (is_null($tYPE)) {
            throw new \InvalidArgumentException('non-nullable tYPE cannot be null');
        }
        $allowedValues = $this->getTYPEAllowableValues();
        if (!in_array($tYPE, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'tYPE', must be one of '%s'",
                    $tYPE,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tYPE'] = $tYPE;

        return $this;
    }

    /**
     * Gets wEATHER
     *
     * @return string[]|null
     */
    public function getWEATHER()
    {
        return $this->container['wEATHER'];
    }

    /**
     * Sets wEATHER
     *
     * @param string[]|null $wEATHER wEATHER
     *
     * @return self
     */
    public function setWEATHER($wEATHER)
    {
        if (is_null($wEATHER)) {
            throw new \InvalidArgumentException('non-nullable wEATHER cannot be null');
        }
        $allowedValues = $this->getWEATHERAllowableValues();
        if (array_diff($wEATHER, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'wEATHER', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['wEATHER'] = $wEATHER;

        return $this;
    }

    /**
     * Gets fREETEXT
     *
     * @return string|null
     */
    public function getFREETEXT()
    {
        return $this->container['fREETEXT'];
    }

    /**
     * Sets fREETEXT
     *
     * @param string|null $fREETEXT Optionnel La localisation de l'affaire est transmise en amont dans un message RC-EDA et le lieu souhaité pour l'intervention est systématiquement reprécisé dans un objet MISSION
     *
     * @return self
     */
    public function setFREETEXT($fREETEXT)
    {
        if (is_null($fREETEXT)) {
            throw new \InvalidArgumentException('non-nullable fREETEXT cannot be null');
        }
        $this->container['fREETEXT'] = $fREETEXT;

        return $this;
    }

    /**
     * Gets pOSITION
     *
     * @return \Hubsante\Model\emsi\Position|null
     */
    public function getPOSITION()
    {
        return $this->container['pOSITION'];
    }

    /**
     * Sets pOSITION
     *
     * @param \Hubsante\Model\emsi\Position|null $pOSITION pOSITION
     *
     * @return self
     */
    public function setPOSITION($pOSITION)
    {
        if (is_null($pOSITION)) {
            throw new \InvalidArgumentException('non-nullable pOSITION cannot be null');
        }
        $this->container['pOSITION'] = $pOSITION;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


