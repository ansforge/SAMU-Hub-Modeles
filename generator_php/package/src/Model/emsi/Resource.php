<?php
/**
 * Resource
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Hubsante
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OpenAPI
 *
 * OpenAPI
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Hubsante\Model\emsi;

use \ArrayAccess;
use \Hubsante\ObjectSerializer;

/**
 * Resource Class Doc Comment
 *
 * @category Class
 * @package  Hubsante
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Resource implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'resource';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'rTYPE' => '\Hubsante\Model\emsi\Rtype',
        'iD' => 'string',
        'oRGID' => 'string',
        'nAME' => 'string',
        'fREETEXT' => 'string',
        'rGEO' => '\Hubsante\Model\emsi\Rgeo[]',
        'qUANTITY' => 'float',
        'uM' => 'string',
        'sTATUS' => 'string',
        'nATIONALITY' => 'string',
        'cONTACTS' => '\Hubsante\Model\emsi\Contact[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'rTYPE' => null,
        'iD' => null,
        'oRGID' => null,
        'nAME' => null,
        'fREETEXT' => null,
        'rGEO' => null,
        'qUANTITY' => null,
        'uM' => null,
        'sTATUS' => null,
        'nATIONALITY' => null,
        'cONTACTS' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'rTYPE' => false,
        'iD' => false,
        'oRGID' => false,
        'nAME' => false,
        'fREETEXT' => false,
        'rGEO' => false,
        'qUANTITY' => false,
        'uM' => false,
        'sTATUS' => false,
        'nATIONALITY' => false,
        'cONTACTS' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'rTYPE' => 'RTYPE',
        'iD' => 'ID',
        'oRGID' => 'ORG_ID',
        'nAME' => 'NAME',
        'fREETEXT' => 'FREETEXT',
        'rGEO' => 'RGEO',
        'qUANTITY' => 'QUANTITY',
        'uM' => 'UM',
        'sTATUS' => 'STATUS',
        'nATIONALITY' => 'NATIONALITY',
        'cONTACTS' => 'CONTACTS'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'rTYPE' => 'setRTYPE',
        'iD' => 'setID',
        'oRGID' => 'setORGID',
        'nAME' => 'setNAME',
        'fREETEXT' => 'setFREETEXT',
        'rGEO' => 'setRGEO',
        'qUANTITY' => 'setQUANTITY',
        'uM' => 'setUM',
        'sTATUS' => 'setSTATUS',
        'nATIONALITY' => 'setNATIONALITY',
        'cONTACTS' => 'setCONTACTS'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'rTYPE' => 'getRTYPE',
        'iD' => 'getID',
        'oRGID' => 'getORGID',
        'nAME' => 'getNAME',
        'fREETEXT' => 'getFREETEXT',
        'rGEO' => 'getRGEO',
        'qUANTITY' => 'getQUANTITY',
        'uM' => 'getUM',
        'sTATUS' => 'getSTATUS',
        'nATIONALITY' => 'getNATIONALITY',
        'cONTACTS' => 'getCONTACTS'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const U_M_LSV = 'LSV';
    public const U_M_OTH = 'OTH';
    public const U_M_PKG = 'PKG';
    public const U_M_TIM = 'TIM';
    public const U_M_WGT = 'WGT';
    public const U_M_LSV_CM = 'LSV/CM';
    public const U_M_LSV_CMH = 'LSV/CMH';
    public const U_M_LSV_CNTLTR = 'LSV/CNTLTR';
    public const U_M_LSV_DEG = 'LSV/DEG';
    public const U_M_LSV_HCTLTR = 'LSV/HCTLTR';
    public const U_M_LSV_HCTMTR = 'LSV/HCTMTR';
    public const U_M_LSV_KM = 'LSV/KM';
    public const U_M_LSV_KPH = 'LSV/KPH';
    public const U_M_LSV_LI = 'LSV/LI';
    public const U_M_LSV_LTPRHR = 'LSV/LTPRHR';
    public const U_M_LSV_LTPRMN = 'LSV/LTPRMN';
    public const U_M_LSV_METRE = 'LSV/METRE';
    public const U_M_LSV_MILLTR = 'LSV/MILLTR';
    public const U_M_LSV_MILMTR = 'LSV/MILMTR';
    public const U_M_LSV_SMH = 'LSV/SMH';
    public const U_M_LSV_SQM = 'LSV/SQM';
    public const U_M_OTH_COIL = 'OTH/COIL';
    public const U_M_OTH_DOZEN = 'OTH/DOZEN';
    public const U_M_OTH_EA = 'OTH/EA';
    public const U_M_OTH_GROSS = 'OTH/GROSS';
    public const U_M_OTH_MANHUR = 'OTH/MANHUR';
    public const U_M_OTH_MHPRHR = 'OTH/MHPRHR';
    public const U_M_PKG_BALE = 'PKG/BALE';
    public const U_M_PKG_BARREL = 'PKG/BARREL';
    public const U_M_PKG_BLK = 'PKG/BLK';
    public const U_M_PKG_BOX = 'PKG/BOX';
    public const U_M_PKG_CASE = 'PKG/CASE';
    public const U_M_PKG_CONTNR = 'PKG/CONTNR';
    public const U_M_PKG_CRATE = 'PKG/CRATE';
    public const U_M_PKG_DRM = 'PKG/DRM';
    public const U_M_PKG_JERCAN = 'PKG/JERCAN';
    public const U_M_PKG_PAK = 'PKG/PAK';
    public const U_M_PKG_PAL = 'PKG/PAL';
    public const U_M_PKG_RATION = 'PKG/RATION';
    public const U_M_TIM_DAY = 'TIM/DAY';
    public const U_M_TIM_HR = 'TIM/HR';
    public const U_M_TIM_MINUTE = 'TIM/MINUTE';
    public const U_M_TIM_MON = 'TIM/MON';
    public const U_M_TIM_SECOND = 'TIM/SECOND';
    public const U_M_TIM_WEK = 'TIM/WEK';
    public const U_M_TIM_YEA = 'TIM/YEA';
    public const U_M_WGT_CNTGRM = 'WGT/CNTGRM';
    public const U_M_WGT_GRAM = 'WGT/GRAM';
    public const U_M_WGT_KG = 'WGT/KG';
    public const U_M_WGT_KGH = 'WGT/KGH';
    public const S_TATUS_AVAILB = 'AVAILB';
    public const S_TATUS_UNAV = 'UNAV';
    public const S_TATUS_MAINTC = 'MAINTC';
    public const S_TATUS_RESRVD = 'RESRVD';
    public const S_TATUS_VIRTUAL = 'VIRTUAL';
    public const S_TATUS_IN_USE_MOBILE = 'IN_USE/MOBILE';
    public const S_TATUS_IN_USE_ON_SCENE = 'IN_USE/ON_SCENE';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getUMAllowableValues()
    {
        return [
            self::U_M_LSV,
            self::U_M_OTH,
            self::U_M_PKG,
            self::U_M_TIM,
            self::U_M_WGT,
            self::U_M_LSV_CM,
            self::U_M_LSV_CMH,
            self::U_M_LSV_CNTLTR,
            self::U_M_LSV_DEG,
            self::U_M_LSV_HCTLTR,
            self::U_M_LSV_HCTMTR,
            self::U_M_LSV_KM,
            self::U_M_LSV_KPH,
            self::U_M_LSV_LI,
            self::U_M_LSV_LTPRHR,
            self::U_M_LSV_LTPRMN,
            self::U_M_LSV_METRE,
            self::U_M_LSV_MILLTR,
            self::U_M_LSV_MILMTR,
            self::U_M_LSV_SMH,
            self::U_M_LSV_SQM,
            self::U_M_OTH_COIL,
            self::U_M_OTH_DOZEN,
            self::U_M_OTH_EA,
            self::U_M_OTH_GROSS,
            self::U_M_OTH_MANHUR,
            self::U_M_OTH_MHPRHR,
            self::U_M_PKG_BALE,
            self::U_M_PKG_BARREL,
            self::U_M_PKG_BLK,
            self::U_M_PKG_BOX,
            self::U_M_PKG_CASE,
            self::U_M_PKG_CONTNR,
            self::U_M_PKG_CRATE,
            self::U_M_PKG_DRM,
            self::U_M_PKG_JERCAN,
            self::U_M_PKG_PAK,
            self::U_M_PKG_PAL,
            self::U_M_PKG_RATION,
            self::U_M_TIM_DAY,
            self::U_M_TIM_HR,
            self::U_M_TIM_MINUTE,
            self::U_M_TIM_MON,
            self::U_M_TIM_SECOND,
            self::U_M_TIM_WEK,
            self::U_M_TIM_YEA,
            self::U_M_WGT_CNTGRM,
            self::U_M_WGT_GRAM,
            self::U_M_WGT_KG,
            self::U_M_WGT_KGH,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSTATUSAllowableValues()
    {
        return [
            self::S_TATUS_AVAILB,
            self::S_TATUS_UNAV,
            self::S_TATUS_MAINTC,
            self::S_TATUS_RESRVD,
            self::S_TATUS_VIRTUAL,
            self::S_TATUS_IN_USE_MOBILE,
            self::S_TATUS_IN_USE_ON_SCENE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('rTYPE', $data ?? [], null);
        $this->setIfExists('iD', $data ?? [], null);
        $this->setIfExists('oRGID', $data ?? [], null);
        $this->setIfExists('nAME', $data ?? [], null);
        $this->setIfExists('fREETEXT', $data ?? [], null);
        $this->setIfExists('rGEO', $data ?? [], null);
        $this->setIfExists('qUANTITY', $data ?? [], null);
        $this->setIfExists('uM', $data ?? [], null);
        $this->setIfExists('sTATUS', $data ?? [], null);
        $this->setIfExists('nATIONALITY', $data ?? [], null);
        $this->setIfExists('cONTACTS', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['rTYPE'] === null) {
            $invalidProperties[] = "'rTYPE' can't be null";
        }
        if ($this->container['iD'] === null) {
            $invalidProperties[] = "'iD' can't be null";
        }
        if ($this->container['nAME'] === null) {
            $invalidProperties[] = "'nAME' can't be null";
        }
        $allowedValues = $this->getUMAllowableValues();
        if (!is_null($this->container['uM']) && !in_array($this->container['uM'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'uM', must be one of '%s'",
                $this->container['uM'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['sTATUS'] === null) {
            $invalidProperties[] = "'sTATUS' can't be null";
        }
        $allowedValues = $this->getSTATUSAllowableValues();
        if (!is_null($this->container['sTATUS']) && !in_array($this->container['sTATUS'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sTATUS', must be one of '%s'",
                $this->container['sTATUS'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets rTYPE
     *
     * @return \Hubsante\Model\emsi\Rtype
     */
    public function getRTYPE()
    {
        return $this->container['rTYPE'];
    }

    /**
     * Sets rTYPE
     *
     * @param \Hubsante\Model\emsi\Rtype $rTYPE rTYPE
     *
     * @return self
     */
    public function setRTYPE($rTYPE)
    {
        if (is_null($rTYPE)) {
            throw new \InvalidArgumentException('non-nullable rTYPE cannot be null');
        }
        $this->container['rTYPE'] = $rTYPE;

        return $this;
    }

    /**
     * Gets iD
     *
     * @return string
     */
    public function getID()
    {
        return $this->container['iD'];
    }

    /**
     * Sets iD
     *
     * @param string $iD Identifiant unique de la ressource  dans le système du partenaire propriétaire. Les systèmes sont garants de l'unicité et de l'invariablité des ids de véhicule dans le temps. Ils peuvent se servir des ids dans les référentiels existants si ils sont uniques et stables. Dans le cas d'un véhicule agrégé par un LRM (comme un SMUR), l'ID doit être valorisé avec son immatriculation. Dans le cas d'un véhicule agrégé par NexSIS, l'ID fournit peut ne pas correspondre à une immatriculation.
     *
     * @return self
     */
    public function setID($iD)
    {
        if (is_null($iD)) {
            throw new \InvalidArgumentException('non-nullable iD cannot be null');
        }
        $this->container['iD'] = $iD;

        return $this;
    }

    /**
     * Gets oRGID
     *
     * @return string|null
     */
    public function getORGID()
    {
        return $this->container['oRGID'];
    }

    /**
     * Sets oRGID
     *
     * @param string|null $oRGID Identifiant de l'organisation à laquelle la ressource est rattachée (caserne, SAMU etc). Se référer au DSF pour la structure normée des organisations. Le format est le suivant {pays}.{domaine}.{organisation}.{structure interne}*.{unité fonctionnelle}*. Dans le cas où le LRM/NexSIS sert d'aggrégateur pour des véhicules appartenant à un partenaire tiers (type ambulance privée), l'identifiant d'organisation permet d'identifier ce tiers. A constituer par le rédacteur du présent EMSI pour être unique.
     *
     * @return self
     */
    public function setORGID($oRGID)
    {
        if (is_null($oRGID)) {
            throw new \InvalidArgumentException('non-nullable oRGID cannot be null');
        }
        $this->container['oRGID'] = $oRGID;

        return $this;
    }

    /**
     * Gets nAME
     *
     * @return string
     */
    public function getNAME()
    {
        return $this->container['nAME'];
    }

    /**
     * Sets nAME
     *
     * @param string $nAME Nom donné à la ressource par le partenaire. L'immatriculation peut être utilisée dans le nom courant des véhicules. Dans le cas pompier, les véhicules sont nommés Dans le cas d'équipier, cela peut être leur nom
     *
     * @return self
     */
    public function setNAME($nAME)
    {
        if (is_null($nAME)) {
            throw new \InvalidArgumentException('non-nullable nAME cannot be null');
        }
        $this->container['nAME'] = $nAME;

        return $this;
    }

    /**
     * Gets fREETEXT
     *
     * @return string|null
     */
    public function getFREETEXT()
    {
        return $this->container['fREETEXT'];
    }

    /**
     * Sets fREETEXT
     *
     * @param string|null $fREETEXT Texte libre permettant de décrire la ressource où d'ajouter des précisions sur son engagement. Permet aussi notamment de décrire des attributs librement pour la ressource. Par exemple, pour un véhicule, sa plaque d'immatriculation.
     *
     * @return self
     */
    public function setFREETEXT($fREETEXT)
    {
        if (is_null($fREETEXT)) {
            throw new \InvalidArgumentException('non-nullable fREETEXT cannot be null');
        }
        $this->container['fREETEXT'] = $fREETEXT;

        return $this;
    }

    /**
     * Gets rGEO
     *
     * @return \Hubsante\Model\emsi\Rgeo[]|null
     */
    public function getRGEO()
    {
        return $this->container['rGEO'];
    }

    /**
     * Sets rGEO
     *
     * @param \Hubsante\Model\emsi\Rgeo[]|null $rGEO rGEO
     *
     * @return self
     */
    public function setRGEO($rGEO)
    {
        if (is_null($rGEO)) {
            throw new \InvalidArgumentException('non-nullable rGEO cannot be null');
        }
        $this->container['rGEO'] = $rGEO;

        return $this;
    }

    /**
     * Gets qUANTITY
     *
     * @return float|null
     */
    public function getQUANTITY()
    {
        return $this->container['qUANTITY'];
    }

    /**
     * Sets qUANTITY
     *
     * @param float|null $qUANTITY Dans le cadre d'un échange d'opération, optionnel. Permet de quantifier une ressource : - à ne pas utiliser pour les véhicules ni le personnel - utilisable pour du matériel - utilisable pour des consommables (dans le cas de consommable, à compléter avec le champ UM)
     *
     * @return self
     */
    public function setQUANTITY($qUANTITY)
    {
        if (is_null($qUANTITY)) {
            throw new \InvalidArgumentException('non-nullable qUANTITY cannot be null');
        }
        $this->container['qUANTITY'] = $qUANTITY;

        return $this;
    }

    /**
     * Gets uM
     *
     * @return string|null
     */
    public function getUM()
    {
        return $this->container['uM'];
    }

    /**
     * Sets uM
     *
     * @param string|null $uM Dans le cadre d'un échange d'opération, optionnel. Unité de mesure pour des ressources consommables
     *
     * @return self
     */
    public function setUM($uM)
    {
        if (is_null($uM)) {
            throw new \InvalidArgumentException('non-nullable uM cannot be null');
        }
        $allowedValues = $this->getUMAllowableValues();
        if (!in_array($uM, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'uM', must be one of '%s'",
                    $uM,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['uM'] = $uM;

        return $this;
    }

    /**
     * Gets sTATUS
     *
     * @return string
     */
    public function getSTATUS()
    {
        return $this->container['sTATUS'];
    }

    /**
     * Sets sTATUS
     *
     * @param string $sTATUS Définit le statut de disponibilité d'une ressource. - AVAILB : Lorsqu'une mission est terminée, une ressource redevient disponible - RESRVD : Lorsque la ressource est réservée pour intervenir sur l'affaire mais pas encore engagée dans l'opération. Par exemple : un SMUR termine un autre transfert patient/victime avant de rejoindre une autre intervention : il est alors RESRVD - IN_USE/MOBILE : à utiliser pour les véhicules et le personnel lorsqu'ils se déplaces - IN_USE/ON_SCENE : à utiliser pour les véhicules et le personnel lorsqu'ils sont sur les lieux de l'affaire
     *
     * @return self
     */
    public function setSTATUS($sTATUS)
    {
        if (is_null($sTATUS)) {
            throw new \InvalidArgumentException('non-nullable sTATUS cannot be null');
        }
        $allowedValues = $this->getSTATUSAllowableValues();
        if (!in_array($sTATUS, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sTATUS', must be one of '%s'",
                    $sTATUS,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sTATUS'] = $sTATUS;

        return $this;
    }

    /**
     * Gets nATIONALITY
     *
     * @return string|null
     */
    public function getNATIONALITY()
    {
        return $this->container['nATIONALITY'];
    }

    /**
     * Sets nATIONALITY
     *
     * @param string|null $nATIONALITY Nationalité d'une ressource, réemployer ISO 3166-1-alpha-2 code elements.
     *
     * @return self
     */
    public function setNATIONALITY($nATIONALITY)
    {
        if (is_null($nATIONALITY)) {
            throw new \InvalidArgumentException('non-nullable nATIONALITY cannot be null');
        }
        $this->container['nATIONALITY'] = $nATIONALITY;

        return $this;
    }

    /**
     * Gets cONTACTS
     *
     * @return \Hubsante\Model\emsi\Contact[]|null
     */
    public function getCONTACTS()
    {
        return $this->container['cONTACTS'];
    }

    /**
     * Sets cONTACTS
     *
     * @param \Hubsante\Model\emsi\Contact[]|null $cONTACTS cONTACTS
     *
     * @return self
     */
    public function setCONTACTS($cONTACTS)
    {
        if (is_null($cONTACTS)) {
            throw new \InvalidArgumentException('non-nullable cONTACTS cannot be null');
        }
        $this->container['cONTACTS'] = $cONTACTS;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


