/*
 * OpenAPI
 *
 * OpenAPI
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = HubsanteModel/Cisu.Client.OpenAPIDateConverter;

namespace HubsanteModel/Cisu.Model
{
    /// <summary>
    /// Alert
    /// </summary>
    [DataContract(Name = "alert")]
    public partial class Alert : IValidatableObject
    {
        /// <summary>
        /// Permet d&#39;attirer l&#39;attention des forces partenaires sur une affaire pour le faire sortir du lot. Eventuellement automatisé en fonction des critères saisis et de leur paramétrage, ou renseigné par l&#39;opérateur.  Prend les valeurs définies dans la nomenclature CISU : - standard : STANDARD - signalé : ATTENTION Les systèmes peuvent proposer des fonctionnalités faisant ressortir les dossiers avec le libellé ATTENTION
        /// </summary>
        /// <value>Permet d&#39;attirer l&#39;attention des forces partenaires sur une affaire pour le faire sortir du lot. Eventuellement automatisé en fonction des critères saisis et de leur paramétrage, ou renseigné par l&#39;opérateur.  Prend les valeurs définies dans la nomenclature CISU : - standard : STANDARD - signalé : ATTENTION Les systèmes peuvent proposer des fonctionnalités faisant ressortir les dossiers avec le libellé ATTENTION</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ReportingEnum
        {
            /// <summary>
            /// Enum STANDARD for value: STANDARD
            /// </summary>
            [EnumMember(Value = "STANDARD")]
            STANDARD = 1,

            /// <summary>
            /// Enum ATTENTION for value: ATTENTION
            /// </summary>
            [EnumMember(Value = "ATTENTION")]
            ATTENTION = 2
        }


        /// <summary>
        /// Permet d&#39;attirer l&#39;attention des forces partenaires sur une affaire pour le faire sortir du lot. Eventuellement automatisé en fonction des critères saisis et de leur paramétrage, ou renseigné par l&#39;opérateur.  Prend les valeurs définies dans la nomenclature CISU : - standard : STANDARD - signalé : ATTENTION Les systèmes peuvent proposer des fonctionnalités faisant ressortir les dossiers avec le libellé ATTENTION
        /// </summary>
        /// <value>Permet d&#39;attirer l&#39;attention des forces partenaires sur une affaire pour le faire sortir du lot. Eventuellement automatisé en fonction des critères saisis et de leur paramétrage, ou renseigné par l&#39;opérateur.  Prend les valeurs définies dans la nomenclature CISU : - standard : STANDARD - signalé : ATTENTION Les systèmes peuvent proposer des fonctionnalités faisant ressortir les dossiers avec le libellé ATTENTION</value>
        /*
        <example>example.json#/initialAlert/reporting</example>
        */
        [DataMember(Name = "reporting", IsRequired = true, EmitDefaultValue = true)]
        public ReportingEnum Reporting { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Alert" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Alert() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Alert" /> class.
        /// </summary>
        /// <param name="id">Identifiant technique unique de l&#39;alerte. Il doit pouvoir être généré automatiquement par le système émetteur et ne doit pas avoir de signification / utilisation particulière par les différents systèmes pour garantir leur découplage. Voir la description de l&#39;identifiant de l&#39;affaire pour voir le format. Lorsqu’une alerte est générée dans NexSIS et crée une affaire, elle est qualifiée d’Alerte Initiale. a) Si cette dernière concerne un partenaire (caractère médical pour la Santé par exemple), elle est relayée seule dans le message. Il y’a un seul objet initialAlert. b) Sinon, une autre alerte liée à la même affaire peut être déclarée ultérieurement, concernant cette fois le partenaire. Lorsqu’elle est déclarée cette Nouvelle Alerte est relayée avec l’Alerte Initiale pour partager un contexte commun. Dans le message de création d’affaire il y’a deux objets alerte : initialAlert et newAlert. Le rattachement des messages à une affaire doivent s&#39;appuyer sur les caseId et non les alertId qui peuvent varier d&#39;un système à l&#39;autre. (required).</param>
        /// <param name="reception">A valoriser avec le groupe date heure de réception de l&#39;alerte/appel (required).</param>
        /// <param name="reporting">Permet d&#39;attirer l&#39;attention des forces partenaires sur une affaire pour le faire sortir du lot. Eventuellement automatisé en fonction des critères saisis et de leur paramétrage, ou renseigné par l&#39;opérateur.  Prend les valeurs définies dans la nomenclature CISU : - standard : STANDARD - signalé : ATTENTION Les systèmes peuvent proposer des fonctionnalités faisant ressortir les dossiers avec le libellé ATTENTION (required).</param>
        /// <param name="notes">notes.</param>
        /// <param name="caller">caller (required).</param>
        /// <param name="location">location (required).</param>
        /// <param name="qualification">qualification (required).</param>
        /// <param name="callTaker">callTaker (required).</param>
        /// <param name="attachment">attachment.</param>
        public Alert(string id = default(string), DateTime reception = default(DateTime), ReportingEnum reporting = default(ReportingEnum), List<Notes> notes = default(List<Notes>), Caller caller = default(Caller), Location location = default(Location), Qualification qualification = default(Qualification), CallTaker callTaker = default(CallTaker), List<Attachment> attachment = default(List<Attachment>))
        {
            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new ArgumentNullException("id is a required property for Alert and cannot be null");
            }
            this.Id = id;
            this.Reception = reception;
            this.Reporting = reporting;
            // to ensure "caller" is required (not null)
            if (caller == null)
            {
                throw new ArgumentNullException("caller is a required property for Alert and cannot be null");
            }
            this.Caller = caller;
            // to ensure "location" is required (not null)
            if (location == null)
            {
                throw new ArgumentNullException("location is a required property for Alert and cannot be null");
            }
            this.Location = location;
            // to ensure "qualification" is required (not null)
            if (qualification == null)
            {
                throw new ArgumentNullException("qualification is a required property for Alert and cannot be null");
            }
            this.Qualification = qualification;
            // to ensure "callTaker" is required (not null)
            if (callTaker == null)
            {
                throw new ArgumentNullException("callTaker is a required property for Alert and cannot be null");
            }
            this.CallTaker = callTaker;
            this.Notes = notes;
            this.Attachment = attachment;
        }

        /// <summary>
        /// Identifiant technique unique de l&#39;alerte. Il doit pouvoir être généré automatiquement par le système émetteur et ne doit pas avoir de signification / utilisation particulière par les différents systèmes pour garantir leur découplage. Voir la description de l&#39;identifiant de l&#39;affaire pour voir le format. Lorsqu’une alerte est générée dans NexSIS et crée une affaire, elle est qualifiée d’Alerte Initiale. a) Si cette dernière concerne un partenaire (caractère médical pour la Santé par exemple), elle est relayée seule dans le message. Il y’a un seul objet initialAlert. b) Sinon, une autre alerte liée à la même affaire peut être déclarée ultérieurement, concernant cette fois le partenaire. Lorsqu’elle est déclarée cette Nouvelle Alerte est relayée avec l’Alerte Initiale pour partager un contexte commun. Dans le message de création d’affaire il y’a deux objets alerte : initialAlert et newAlert. Le rattachement des messages à une affaire doivent s&#39;appuyer sur les caseId et non les alertId qui peuvent varier d&#39;un système à l&#39;autre.
        /// </summary>
        /// <value>Identifiant technique unique de l&#39;alerte. Il doit pouvoir être généré automatiquement par le système émetteur et ne doit pas avoir de signification / utilisation particulière par les différents systèmes pour garantir leur découplage. Voir la description de l&#39;identifiant de l&#39;affaire pour voir le format. Lorsqu’une alerte est générée dans NexSIS et crée une affaire, elle est qualifiée d’Alerte Initiale. a) Si cette dernière concerne un partenaire (caractère médical pour la Santé par exemple), elle est relayée seule dans le message. Il y’a un seul objet initialAlert. b) Sinon, une autre alerte liée à la même affaire peut être déclarée ultérieurement, concernant cette fois le partenaire. Lorsqu’elle est déclarée cette Nouvelle Alerte est relayée avec l’Alerte Initiale pour partager un contexte commun. Dans le message de création d’affaire il y’a deux objets alerte : initialAlert et newAlert. Le rattachement des messages à une affaire doivent s&#39;appuyer sur les caseId et non les alertId qui peuvent varier d&#39;un système à l&#39;autre.</value>
        /*
        <example>example.json#/initialAlert/id</example>
        */
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = true)]
        public string Id { get; set; }

        /// <summary>
        /// A valoriser avec le groupe date heure de réception de l&#39;alerte/appel
        /// </summary>
        /// <value>A valoriser avec le groupe date heure de réception de l&#39;alerte/appel</value>
        [DataMember(Name = "reception", IsRequired = true, EmitDefaultValue = true)]
        public DateTime Reception { get; set; }

        /// <summary>
        /// Gets or Sets Notes
        /// </summary>
        [DataMember(Name = "notes", EmitDefaultValue = false)]
        public List<Notes> Notes { get; set; }

        /// <summary>
        /// Gets or Sets Caller
        /// </summary>
        [DataMember(Name = "caller", IsRequired = true, EmitDefaultValue = true)]
        public Caller Caller { get; set; }

        /// <summary>
        /// Gets or Sets Location
        /// </summary>
        [DataMember(Name = "location", IsRequired = true, EmitDefaultValue = true)]
        public Location Location { get; set; }

        /// <summary>
        /// Gets or Sets Qualification
        /// </summary>
        [DataMember(Name = "qualification", IsRequired = true, EmitDefaultValue = true)]
        public Qualification Qualification { get; set; }

        /// <summary>
        /// Gets or Sets CallTaker
        /// </summary>
        [DataMember(Name = "callTaker", IsRequired = true, EmitDefaultValue = true)]
        public CallTaker CallTaker { get; set; }

        /// <summary>
        /// Gets or Sets Attachment
        /// </summary>
        [DataMember(Name = "attachment", EmitDefaultValue = false)]
        public List<Attachment> Attachment { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Alert {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Reception: ").Append(Reception).Append("\n");
            sb.Append("  Reporting: ").Append(Reporting).Append("\n");
            sb.Append("  Notes: ").Append(Notes).Append("\n");
            sb.Append("  Caller: ").Append(Caller).Append("\n");
            sb.Append("  Location: ").Append(Location).Append("\n");
            sb.Append("  Qualification: ").Append(Qualification).Append("\n");
            sb.Append("  CallTaker: ").Append(CallTaker).Append("\n");
            sb.Append("  Attachment: ").Append(Attachment).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Reception != null) {
                // Reception (DateTime) pattern
                Regex regexReception = new Regex(@"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}[\-+]\d{2}:\d{2}$", RegexOptions.CultureInvariant);
                if (!regexReception.Match(this.Reception).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reception, must match a pattern of " + regexReception, new [] { "Reception" });
                }
            }

            yield break;
        }
    }

}
