<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Validator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">models-2</a> &gt; <a href="index.source.html" class="el_package">com.hubsante.model</a> &gt; <span class="el_source">Validator.java</span></div><h1>Validator.java</h1><pre class="source lang-java linenums">/**
 * Copyright Â© 2023 Agence du Numerique en Sante (ANS)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hubsante.model;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hubsante.model.exception.ValidationException;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import lombok.extern.slf4j.Slf4j;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Set;

@Slf4j
public class Validator {

    private ObjectMapper jsonMapper;
    private XmlMapper xmlMapper;

<span class="fc" id="L52">    public Validator() {</span>
<span class="fc" id="L53">        xmlMapper = (XmlMapper) new XmlMapper()</span>
<span class="fc" id="L54">                .registerModule(new JavaTimeModule())</span>
<span class="fc" id="L55">                .enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)</span>
<span class="fc" id="L56">                .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)</span>
<span class="fc" id="L57">                .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)</span>
<span class="fc" id="L58">                .disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);</span>

<span class="fc" id="L60">        xmlMapper.configure(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true);</span>

<span class="fc" id="L62">        jsonMapper = new ObjectMapper()</span>
<span class="fc" id="L63">                .registerModule(new JavaTimeModule())</span>
<span class="fc" id="L64">                .enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)</span>
<span class="fc" id="L65">                .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)</span>
<span class="fc" id="L66">                .disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);</span>

        // We explicitly set the Locale to ensure cross platform consistency
<span class="fc" id="L69">        Locale.setDefault(Locale.ENGLISH);</span>
<span class="fc" id="L70">    }</span>

    public void validateXML(String message, String xsdFile) throws IOException, ValidationException {
        try {
<span class="nc" id="L74">            javax.xml.validation.Validator validator = initValidator(xsdFile);</span>
<span class="nc" id="L75">            validator.validate(new StreamSource(new StringReader(message)));</span>
<span class="nc" id="L76">        } catch (SAXException e) {</span>
            // TODO bbo: check what message is wrapped by SAXException
<span class="nc" id="L78">            throw new ValidationException(&quot;Could not validate message against schema : errors occurred. \n&quot; + e.getMessage());</span>
<span class="nc" id="L79">        }</span>
<span class="nc" id="L80">    }</span>

    private javax.xml.validation.Validator initValidator(String xsdPath) throws SAXException {
<span class="nc" id="L83">        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span>
<span class="nc" id="L84">        Source schemaFile = new StreamSource(new File(getClass().getClassLoader().getResource(&quot;xsd/&quot; + xsdPath).getFile()));</span>
<span class="nc" id="L85">        Schema schema = factory.newSchema(schemaFile);</span>
<span class="nc" id="L86">        return schema.newValidator();</span>
    }

    public void validateJSON(String message, String jsonSchemaFile) throws IOException, ValidationException {
<span class="fc" id="L90">        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);</span>
        // If the schema file references local sub-schema, it must reference the classpath as its id
        // the library behavior is to construct an URI from the id, and then add the schema file name to it
        // if the id is a http URI, it will try to download the subschema online
        // Ref.: https://github.com/networknt/json-schema-validator/issues/55
<span class="fc" id="L95">        InputStream schemaStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;json-schema/&quot; + jsonSchemaFile);</span>
<span class="fc" id="L96">        JsonSchema jsonSchema = factory.getSchema(schemaStream);</span>

<span class="fc" id="L98">        JsonNode jsonNode = jsonMapper.readTree(message);</span>
<span class="fc" id="L99">        Set&lt;ValidationMessage&gt; validationMessages = jsonSchema.validate(jsonNode);</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (!validationMessages.isEmpty()) {</span>
<span class="fc" id="L102">            StringBuilder errors = new StringBuilder();</span>

<span class="fc" id="L104">            boolean containsAtLeastOneUseCaseError = false;</span>
<span class="fc" id="L105">            boolean violatesOneOfConstraint = false;</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">            for (ValidationMessage errorMsg : validationMessages) {</span>
<span class="fc" id="L108">                String error = formatValidationErrorMessage(errorMsg);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if (error != null) {</span>
<span class="fc" id="L110">                    errors.append(error).append(&quot;\n&quot;);</span>
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">                    if(!violatesOneOfConstraint &amp;&amp; errorMsg.getType().equals(&quot;oneOf&quot;)){</span>
<span class="fc" id="L112">                        violatesOneOfConstraint = true;</span>
                    }
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">                    if(!containsAtLeastOneUseCaseError &amp;&amp; errorMsg.getPath().contains(&quot;.message.&quot;)){</span>
<span class="fc" id="L115">                        containsAtLeastOneUseCaseError = true;</span>
                    }
                }
<span class="fc" id="L118">            }</span>
            // Append a special error message if the error string does not contain a single &quot;use case&quot; error and
            // the there is no 'oneOf' constraint violation
<span class="fc bfc" id="L121" title="All 4 branches covered.">            if (!containsAtLeastOneUseCaseError &amp;&amp; !violatesOneOfConstraint) {</span>
<span class="fc" id="L122">                errors.append(&quot;could not detect any schemas in the message, at least one is required \n&quot;);</span>
            }
<span class="fc" id="L124">            throw new ValidationException(&quot;Could not validate message against schema : errors occurred. \n&quot; + errors);</span>
        }
<span class="fc" id="L126">    }</span>

    private String formatValidationErrorMessage(ValidationMessage errorMsg) {
        // We split the path string on '.'
<span class="fc" id="L130">        List&lt;String&gt; path = Arrays.asList(errorMsg.getPath().split(&quot;\\.&quot;));</span>
        // We find the index of the element 'message' in the errorMsg's path
<span class="fc" id="L132">        int messageIndex = path.indexOf(&quot;message&quot;);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (messageIndex &lt; 0) {</span>
            // Due to the current state of our schema, which contains only one 'oneOf' constraint,
            // if the error type indicates the violation of that constraint, we verify the argument of the
            // error and ignore it if it is '0' (which means that no use case is valid or there are no use
            // cases in the message at all), otherwise we return the error message.
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if (errorMsg.getType().equals(&quot;oneOf&quot;)) {</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">                return Arrays.stream(errorMsg.getArguments()).anyMatch(arg -&gt; arg.equals(&quot;0&quot;)) ?</span>
<span class="fc" id="L140">                        null : errorMsg.getMessage().substring(errorMsg.getMessage().indexOf(path.get((path.size() - 1))));</span>
            } else {
<span class="nc" id="L142">                return errorMsg.getMessage().substring(errorMsg.getMessage().indexOf(path.get(0)));</span>
            }
<span class="fc bfc" id="L144" title="All 2 branches covered.">        } else if (path.indexOf(&quot;message&quot;) + 1 &gt;= path.size()) {</span>
            // If the path contains the element 'message' and ends immediately after the message 'use case',
            // the error message is irrelevant and we ignore it.
<span class="fc" id="L147">            return null;</span>
        } else {
            // Otherwise, we return the part of error message that comes after the 'message' element
<span class="fc" id="L150">            return errorMsg.getMessage().substring(errorMsg.getMessage().indexOf(&quot;message&quot;) + 8);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>